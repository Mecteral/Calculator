<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ModernRonin.PraeterArtem</name>
    </assembly>
    <members>
        <member name="F:ModernRonin.PraeterArtem.Annotations.AllowedInheritanceOption.BecauseItIsDesignedSo">
            <summary>
            The class is designed to be inherited
            </summary>
        </member>
        <member name="F:ModernRonin.PraeterArtem.Annotations.AllowedInheritanceOption.Because">
            <summary>Some classes may inherit this class in dynamic code 
            (like EntityFramework, Mocks, etc.)
            but in our code this is prohibited </summary>
        </member>
        <member name="F:ModernRonin.PraeterArtem.Annotations.AllowedInheritanceOption.EfCodeFirstEntity">
            <summary>
            Entity framework code-first POCO entity
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Annotations.DataTransferObjectAttribute">
            <summary>Marks DTO classes</summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Annotations.MarkerClassAttribute">
            <summary> Allows ctor-s only </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Annotations.NamespaceObjectAttribute">
            <summary>Static class that is has only constants, static read-only fields, and nested classes</summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.DateTimeExtensions">
            <summary>
            Contains extension methods for DateTime, basically stuff frequently
            needed and missing in the BCL.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.DateTimeExtensions.ToUnixTime(System.DateTime)">
            <summary>
            Returns a unix-timestamp for the given DateTime. DateTime can be
            local or UTC.
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.DateTimeExtensions.FromUnixTimeToUtc(System.Int32)">
            <summary>Returns a UTC datetime for a given unix-timestamp.</summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Functional.CollectionExtensions">
            <summary>Contains extension methods for <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.CollectionExtensions.RemoveWhere``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
            <summary>Removes all elements from <paramref name="collection"/> matching
            <paramref name="predicate"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="predicate"></param>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Functional.ComparableExtensions">
            <summary>
                Extension methods on <see cref="T:System.IComparable`1" />.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.ComparableExtensions.IsInClosedInterval``1(``0,``0,``0)">
            <summary>
                Returns whether <paramref name="value" /> is in
                [<paramref name="inclusiveLowerBound" />; <paramref name="inclusiveUpperBound" />]
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="inclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.ComparableExtensions.IsInOpenInterval``1(``0,``0,``0)">
            <summary>
                Returns whether <paramref name="value" /> is in
                [<paramref name="exclusiveLowerBound" />; <paramref name="exclusiveUpperBound" />]
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="exclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Functional.EnumerableExtensions">
            <summary>Contains extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            supporting a functional coding style.</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>More readable replacement for !Any{T}.</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.UseIn``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Passes each argument of <paramref name="enumerable"/> to
            <paramref name="action"/>.</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.ExecuteOn``1(System.Collections.Generic.IEnumerable{System.Action{``0}},``0)">
            <summary>
            Calls each action contained in <paramref name="actions"/> with the
            argument <paramref name="argument"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.ToEnumerable``1(``0)">
            <summary>
            Allows to easily pass single elements into functions expecting an
            IEnumerable.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.AddTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <summary>Adds all element to <paramref name="destination"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="destination"></param>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.ExceptNullValues``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns all elements which are not null.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.ButFirst``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns all elements except the first.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.ButLast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns all elements except the last.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns all elements of <paramref name="enumerable"/> except
            <paramref name="value"/>/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.GreaterThan``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns all elements of <paramref name="enumerable"/>
            which are greater than <paramref name="limit"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.GreaterThanOrEqualTo``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns all elements of <paramref name="enumerable"/>
            which are greater than or equal to <paramref name="limit"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.SmallerThan``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns all elements of <paramref name="enumerable"/>
            which are smaller than <paramref name="limit"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.SmallerThanOrEqualTo``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns all elements of <paramref name="enumerable"/>
            which are smaller than or equal to<paramref name="limit"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.EqualTo``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns all elements of <paramref name="enumerable"/> which are
            equal to <paramref name="check"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.SameAs``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns all elements of <paramref name="enumerable"/>
            which are reference-equal to <paramref name="check"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.MinElement``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Returns the element of <paramref name="enumerable"/>
            with the smallest evaluation when passed to <paramref name="evaluator"/>.
            (In contrast to the BCL .Min() method which returns the minimal value, not
            the minimal element.)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="evaluator"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.MaxElement``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Returns the element of <paramref name="enumerable"/>
            with the greatest evaluation when passed to <paramref name="evaluator"/>.
            (In contrast to the BCL .Max() method which returns the minimal value, not
            the minimal element.)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="evaluator"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.Min``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Overload for the BCL .Min() method which allows to pass a value to
            be used in case
            <paramref name="enumerable"/> is empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="valueToReturnIfEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.Max``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Overload for the BCL .Max() method which allows to pass a value to
            be used in case
            <paramref name="enumerable"/> is empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="valueToReturnIfEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Splits the enumerable into multiple enumerables of size
            <paramref name="chunkSize"/>. Note that the last chunk may contain fewer
            items.
            <example>
            new []{1,2,3,4,5,6,7,8,9, 0}.Chunk(3) will result in 3 chunks with
            3 elements and a fourth chunk with only one element
            </example>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="chunkSize"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.EnumerableExtensions.ToStrings``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns an enumeration of all elements .ToString().</summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Functional.Functions">
            <summary>
            Methods supporting a functional coding style related to Func{T}.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.Functions.Identity``1">
            <summary>Returns a Func{T} which always returns its argument</summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Functional.IntegerExtensions">
            <summary>
                Extensions method on integers supporting a functional coding style
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.IntegerExtensions.TimesExecute(System.Int32,System.Action)">
            <summary>
                Executes <paramref name="action" /> <paramref name="count" /> times.
            </summary>
            <param name="count"></param>
            <param name="action"></param>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Functional.IntegerExtensions.TimesExecute(System.Int32,System.Action{System.Int32})">
            <summary>
                Executes <paramref name="action" /> for all integers in the
                interval [0; <paramref name="count" />[.
            </summary>
            <param name="count"></param>
            <param name="action"></param>
        </member>
        <member name="T:ModernRonin.PraeterArtem.ITimeGiver">
            <summary>
            Abstracts what DateTime.Now does to allow mocking in tests
            and also to more OO distinguish between .Now and .UtcNow.
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.LocalTimeGiver">
            <summary>Implemements <see cref="T:ModernRonin.PraeterArtem.ITimeGiver"/> with Now.</summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Reflection.AppDomainExtensions">
            <summary>Extensions for <see cref="T:System.AppDomain"/>.</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.AppDomainExtensions.CreateTypeInDomain``1(System.AppDomain,System.String,System.String)">
            <summary>
            Creates a type in an <see cref="T:System.AppDomain"/>. Loads the assembly
            where the type should be located into that AppDomain. This is useful if you
            want to dynamically load types and later unload them again. .NET does not
            allow unloading of types or assemblies, but it allows unloading of
            AppDomains. So you create an AppDomain to hold your dynamically loaded types
            (with <see cref="M:System.AppDomain.CreateDomain(System.String)"/>) and then use this
            method.
            </summary>
            <remarks>
            Types loaded MUST inherit from <see cref="T:System.MarshalByRefObject"/>.
            They also MUST implement an interface of your choice. This interface MUST be
            located in an assembly other than the one containing the type to be
            instantiated. You specify this interface with <typeparamref name="T"/>. So
            what you get from this method is an interface, not the concrete type. Also,
            make sure that your code does never refer to anything of the dynamically
            loaded assembly directly. In particular, do NOT use any typeof of a type
            located in that assembly. If you do, the assembly will be loaded into your
            primary AppDomain which cannot be unloaded, thus defeating the whole point
            of the exercise. The interface type denoted by <typeparamref name="T"/>
            MUST NOT be defined in your calling code's assembly, either. Incidentally,
            this is also the reason why you must pass the type to be instantiated as a
            string to this method. Also, note that the type to be instantiated MUST be
            default constructable. While it would have been entirely possible to allow
            parameterized construction, for many cases default construction and object
            initializers are the better choice, anyway, and besides, non-default
            constructable types create hard-to-understand phenomena when being
            serialized (which they must be when crossing domain boundaries). Last not
            least, note that all arguments you pass to methods on a remote type need to
            be marked as [Serialized]. That includes, not so obviously, that if you pass
            lambdas as parameters, the class containing the method in which the lambda
            is defined, needs to be marked as [Serializable], too.
            </remarks>
            <example>
            You have at least three different assemblies:
            <list type="bullet">
                <item>
                    <description>SharedInterfaces</description>
                </item>
                <item>
                    <description>CallingCode</description>
                </item>
                <item>
                    <description>DynamicallyLoadedCode</description>
                </item>
            </list>
            SharedInterfaces contains:
            <code>
            public interface IRemoteType
            {
                  void DoSomething();
            }
            </code>
            DynamicallyLoadedCode references SharedInterfaces and contains:
            <code>
            public class SomeImplementation : MarshalByRefObject, IRemoteType
            {
                public void DoSomething()
                {
                    // implementation
                }
            }        
            </code>
            CallingCode references SharedInterfaces and contains:
            <code>
                const string fullPathToAssembly = "DynamicallyLoadedCode.dll";
                const string namespaceQualifiedTypeName = "DynamicallyLoadedCode.SomeImplementation";
                var remoteType = someDomain.CreateTypeInDomain{IRemoteType}(fullPathToAssembly, namespaceQualifiedTypeName);
            </code>
            </example>
            <typeparam name="T"></typeparam>
            <param name="domain"></param>
            <param name="assemblyFilePath"></param>
            <param name="concreteTypeName"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.AppDomainExtensions.Execute(System.AppDomain,System.Action)">
            <summary>
            Executes an action in another AppDomain. Note that any lambdas
            passed must be serializable. That implies they should not reference local
            variables of the method calling Execute. If the lambda accesses member
            fields of the calling method's class, that class must be marked as
            [Serializable].
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.AppDomainExtensions.Execute``2(System.AppDomain,``0,System.Func{``0,``1})">
            <summary>
            Executes an function with a single parameter in another AppDomain
            and returns the result. Note that any lambdas passed must be serializable.
            That implies they should not reference local variables of the method calling
            Execute. If the lambda accesses member fields of the calling method's class,
            that class must be marked as [Serializable].
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.AppDomainExtensions.Execute``1(System.AppDomain,``0,System.Action{``0})">
            <summary>
            Executes an action with a parameter in another AppDomain. Note that
            any lambdas passed must be serializable. That implies they should not
            reference local variables of the method calling Execute. If the lambda
            accesses member fields of the calling method's class, that class must be
            marked as [Serializable].
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Reflection.MemberInfoExtensions">
            <summary>
            Extensions method on <see cref="T:System.Reflection.MemberInfo"/>, stuff frequently used and missing in the BCL.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.MemberInfoExtensions.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>Check whether an attribute is set for this member.</summary>
            <remarks>Multiple attributes count as true, too. Also, attributes derived from <typeparamref name="T" /> count, too.s</remarks>
            <returns>whether a custom attribute of member <typeparamref name="T" /> is set on <paramref name="member" /></returns>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Reflection.Plugins">
            <summary>
            Helps with enumerating concrete implementations of a specific type
            and with instantiating them.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.Plugins.Instantiate``2(System.Func{``1,``0},System.Func{System.Type,``1})">
            <summary>
            Creates a dictionary of some selector criterion to instances of a certain type.
            Typically, the criterion will be an enum-like property that each type has. 
            For example:
            <example>
            enum SourceLanguage { German, French, Spanish }
            interface ITranslator
            { 
               SourceLanguage HandledLanguage {get;}
               string TranslateToEnglish(string input);
            }
            class GermanTranslator
            {
               SourceLanguage HandledLanguage { get { return SourceLanguage.German; } }
               ...
            }
            class SpanishTranslator ...
            class FrenchTranslator ...
            </example>
            If you called Plugins.Instantiate{SourceLanguage, ITranslator}(t => t.HandledLanguage),
            you'd get {{ SourceLanguage.German -> GermanTranslator}, {SourceLanguage.Spanish -> SpanishTranslator}, {SourceLanguage.French -> FrenchTranslator }}
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TPluginInterface"></typeparam>
            <param name="keyExtractor"></param>
            <param name="creator"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.RemoteDomainExecutor.Execute(System.Action)">
            <summary>
                This MUST be an instance method, otherwise it will be called in the default AppDomain.
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Reflection.TypeExtensions">
            <summary>
                Just a bunch of extensions for <see cref="T:System.Type" /> which MS has forgotten.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.TypeExtensions.HasPublicMethods(System.Type)">
            <summary>
                Indicates whether there are any public methods declared for this type, excluding methods defined in base
                classes.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.TypeExtensions.PrettyName(System.Type)">
            <summary>
                Gets a pretty name for a type even if it is generic. For example, for Dictionary{string,object} it will return
                exactly that instead of
                "Dictionary'1[System.String...] as type.Name would do. Also uses <see cref="M:ModernRonin.PraeterArtem.Reflection.TypeExtensions.CSharpName(System.Type)" />, so CLR types are
                translated to their C# counterparts where possible.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.TypeExtensions.CSharpName(System.Type)">
            <summary>
                Returns the C# type name instead of the CLR type name for those types which have a special name in C#, for example
                "int" instead of Int32 etc.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Reflection.TypeLoader.Load``1(System.String,System.String)">
            <summary>
                This MUST be an instance method, otherwise it will be called in the default AppDomain.
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Scheduling.AThrottlingConfigurable">
            <summary>
            Base class for implementors of <see cref="T:ModernRonin.PraeterArtem.Scheduling.IThrottlingConfigurable"/>.
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Scheduling.IProcessor`1">
            <summary>
            Defines a processor which takes care of throttling of requests and
            accounts for average lag from initialization of a request to its
            fulfillment.
            </summary>
            <typeparam name="TWrappedProcessor"></typeparam>
        </member>
        <member name="P:ModernRonin.PraeterArtem.Scheduling.IProcessor`1.AverageLag">
            <summary>The average time it took to execute a request.</summary>
        </member>
        <member name="P:ModernRonin.PraeterArtem.Scheduling.IProcessor`1.CanCurrentlyExecuteRequest">
            <summary>
            Can a request currently be executed, given throttling parameters
            and latest load?
            </summary>
        </member>
        <member name="P:ModernRonin.PraeterArtem.Scheduling.IProcessor`1.CurrentRequestCountTowardsLimit">
            <summary>How many requests count towards
            <see cref="P:ModernRonin.PraeterArtem.Scheduling.IThrottlingConfigurable.MaximumRequestCountPerDuration"/>
            currently?</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Scheduling.IProcessor`1.Execute(System.Action{`0})">
            <summary>Execute a request.</summary>
            <param name="request"></param>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Scheduling.IScheduler`1">
            <summary>Encapsulates scheduling of jobs over a multitude of
            <see cref="T:ModernRonin.PraeterArtem.Scheduling.IProcessor`1"/>s.</summary>
            <typeparam name="TWrappedProcessor"></typeparam>
        </member>
        <member name="P:ModernRonin.PraeterArtem.Scheduling.IScheduler`1.QueueSize">
            <summary>The number of queued requestes.</summary>
        </member>
        <member name="P:ModernRonin.PraeterArtem.Scheduling.IScheduler`1.NumberOfProcessors">
            <summary>The number of processors registered with this scheduler.</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Scheduling.IScheduler`1.AddProcessor(ModernRonin.PraeterArtem.Scheduling.IProcessor{`0})">
            <summary>Add a processor to this scheduler.</summary>
            <param name="processor"></param>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Scheduling.IScheduler`1.RemoveProcessor(ModernRonin.PraeterArtem.Scheduling.IProcessor{`0})">
            <summary>Remove a processor from this scheduler.</summary>
            <param name="processor"></param>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Scheduling.IScheduler`1.AddRequest(System.Action{`0})">
            <summary>Add a request to the queue of this scheduler.</summary>
            <param name="request"></param>
        </member>
        <member name="M:ModernRonin.PraeterArtem.Scheduling.IScheduler`1.ProcessQueue">
            <summary>
            Process all requests currently queued. This MUST be called
            regularly, otherwise no requests are processed at all.
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Scheduling.IThrottlingConfigurable">
            <summary>
            Defines a contract for throttling of requests. For example, some
            service might require their users to not call them more often than 10 times
            per 1 minute. In that case, <see cref="P:ModernRonin.PraeterArtem.Scheduling.IThrottlingConfigurable.Duration"/> would be set to 1 minute,
            and <see cref="P:ModernRonin.PraeterArtem.Scheduling.IThrottlingConfigurable.MaximumRequestCountPerDuration"/> would be set to 10.
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Scheduling.Processor`1">
            <summary>
            Implements <see cref="T:ModernRonin.PraeterArtem.Scheduling.IProcessor`1"/>.
            </summary>
            <typeparam name="TWrappedProcessor"></typeparam>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Scheduling.ThrottlingScheduler`1">
            <summary>Implements <see cref="T:ModernRonin.PraeterArtem.Scheduling.IScheduler`1"/>.</summary>
            <typeparam name="TWrappedProcessor"></typeparam>
        </member>
        <member name="P:ModernRonin.PraeterArtem.Scheduling.ThrottlingScheduler`1.WeightOfLag">
            <summary>
            When choosing a processor, how much importance should the
            processor's average lag have?
            </summary>
        </member>
        <member name="P:ModernRonin.PraeterArtem.Scheduling.ThrottlingScheduler`1.WeightOfLoad">
            <summary>
            When choosing a processor, how much importance should the
            processor's current number of requests towards the limit have?
            </summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.StringExtensions">
            <summary>
            Contains extension methods for strings, basically stuff frequently
            needed and missing in the BCL.
            </summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.Repeat(System.String,System.Int32)">
            <summary>Returns <paramref name="what"/> repeated <paramref name="count"/>
            times.</summary>
            <param name="what"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.ToMd5Hash(System.String)">
            <summary>Creates an MD5 hash of the string in hexadecimal format.</summary>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.From(System.String,System.Int32)">
            <summary>Returns the string from including the character at
            <paramref name="inclusiveIndex"/>.</summary>
            <param name="source"></param>
            <param name="inclusiveIndex"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.Until(System.String,System.Int32)">
            <summary>Returns the string from the start until excluding the character at
            <paramref name="exclusiveIndex"/>.</summary>
            <param name="source"></param>
            <param name="exclusiveIndex"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.Before(System.String,System.String[])">
            <summary>Returns the string before the first occurrence of any of
            <paramref name="patterns"/>.</summary>
            <param name="source"></param>
            <param name="patterns"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.StartIndexOfAny(System.String,System.String[])">
            <summary>Returns the index of the first occurrence of any of
            <paramref name="patterns"/>.</summary>
            <param name="source"></param>
            <param name="patterns"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.EndIndexOfAny(System.String,System.String[])">
            <summary>Returns the index after the first occurrence of any of
            <paramref name="patterns"/>.</summary>
            <param name="source"></param>
            <param name="patterns"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.After(System.String,System.String[])">
            <summary>Returns the string after the first occurrence of any of
            <paramref name="patterns"/>.</summary>
            <param name="source"></param>
            <param name="patterns"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.SplitIntoLines(System.String)">
            <summary>
            Splits <paramref name="text"/> into lines. Both CR and LF count as
            line separators. Empty lines are discarded.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.LineNumberOfIndex(System.String,System.Int32,System.String[])">
            <summary>
            Interprets <paramref name="text"/> as concatenated lines and
            returns the zero-based index of the line containing what in
            <paramref name="text"/> originally is at character index
            <paramref name="index"/>. If the character at character index
            <paramref name="index"/>
            is a line separator, then the index of the line before that is returned. If
            <paramref name="lineSeparators"/> is not specified, then a sequence of
            "CRLF" is assumed to be the single line separator.
            </summary>
            <param name="text"></param>
            <param name="index"></param>
            <param name="lineSeparators"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.ButFirst(System.String)">
            <summary>
            Returns the string after the first character.
            (If the string is null, null is returned. If it is empty, empty is returned.)
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ModernRonin.PraeterArtem.StringExtensions.ButLast(System.String)">
            <summary>
            Returns the string before the last character.
            (If the string is null, null is returned. If it is empty, empty is returned.)
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="T:ModernRonin.PraeterArtem.UtcTimeGiver">
            <summary>Implemements <see cref="T:ModernRonin.PraeterArtem.ITimeGiver"/> with UtcNow.</summary>
        </member>
        <member name="T:ModernRonin.PraeterArtem.Xml.XElementEqualityComparer">
            <summary>
                An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1" />
                which deals correctly with changed order of attributes or child
                nodes, in contrast to <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:JetBrains.Annotations.AssertionMethodAttribute"/> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
            <seealso cref="T:JetBrains.Annotations.AssertionConditionType"/>
        </member>
        <member name="M:JetBrains.Annotations.AssertionConditionAttribute.#ctor(JetBrains.Annotations.AssertionConditionType)">
            <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
            <param name="conditionType">Specifies condition type</param>
        </member>
        <member name="P:JetBrains.Annotations.AssertionConditionAttribute.ConditionType">
            <summary>
            Gets condition type
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:JetBrains.Annotations.AssertionConditionAttribute"/> attribute
            </summary>
            <seealso cref="T:JetBrains.Annotations.AssertionConditionAttribute"/>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to target attribute, specifies a requirement for any type which is marked with 
            target attribute to implement or inherit specific type or types
            </summary>
            <example>
            <code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute 
            {}
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent
            {}
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Annotations.BaseTypeRequiredAttribute.#ctor(System.Type)">
            <summary>
            Initializes new instance of BaseTypeRequiredAttribute
            </summary>
            <param name="baseType">Specifies which types are required</param>
        </member>
        <member name="P:JetBrains.Annotations.BaseTypeRequiredAttribute.BaseTypes">
            <summary>
            Gets enumerations of specified base types
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
            There is only exception to compare with <c>null</c>, it is permitted
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>
            Only entity marked with attribute considered used
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>
            Indicates implicit assignment to a member
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered to be used implicitly when marked with 
            <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>
            Members of entity marked with attribute are considered used
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>
            Entity marked with attribute and all its members considered used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack. 
            If the parameter is delegate, indicates that delegate is executed while the method is executed.
            If the parameter is enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException"/> has such parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.LocalizationRequiredAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:JetBrains.Annotations.LocalizationRequiredAttribute"/> class.
            </summary>
            <param name="required"><c>true</c> if a element should be localized; otherwise, <c>false</c>.</param>
        </member>
        <member name="P:JetBrains.Annotations.LocalizationRequiredAttribute.Required">
            <summary>
            Gets a value indicating whether a element should be localized.
            <value><c>true</c> if a element should be localized; otherwise, <c>false</c>.</value>
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.LocalizationRequiredAttribute.Equals(System.Object)">
            <summary>
            Returns whether the value of the given object is equal to the current <see cref="T:JetBrains.Annotations.LocalizationRequiredAttribute"/>.
            </summary>
            <param name="obj">The object to test the value equality of. </param>
            <returns>
            <c>true</c> if the value of the given object is equal to that of the current; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:JetBrains.Annotations.LocalizationRequiredAttribute.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A hash code for the current <see cref="T:JetBrains.Annotations.LocalizationRequiredAttribute"/>.</returns>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.MeansImplicitUseAttribute.TargetFlags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of marked element could never be <c>null</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicApiAttribute">
            <summary>
            This attribute is intended to mark publicly available API which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that method doesn't contain observable side effects.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> -like form
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
            <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        </member>
        <member name="P:JetBrains.Annotations.StringFormatMethodAttribute.FormatParameterName">
            <summary>
            Gets format parameter name
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.UsedImplicitlyAttribute.#ctor(System.String)">
            <param name="message">by who?</param>
        </member>
        <member name="P:JetBrains.Annotations.UsedImplicitlyAttribute.TargetFlags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
    </members>
</doc>
